// This file was auto-generated by Fern from our API Definition.

import * as AgentMail from "../../../src/api/index";
import { AgentMailClient } from "../../../src/Client";
import { mockServerPool } from "../../mock-server/MockServerPool";

describe("MetricsClient", () => {
    test("get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new AgentMailClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { http: server.baseUrl, websockets: server.baseUrl },
        });

        const rawResponseBody = {
            message: {
                sent: ["2024-01-15T09:30:00Z", "2024-01-15T09:30:00Z"],
                delivered: ["2024-01-15T09:30:00Z", "2024-01-15T09:30:00Z"],
                bounced: ["2024-01-15T09:30:00Z", "2024-01-15T09:30:00Z"],
                delayed: ["2024-01-15T09:30:00Z", "2024-01-15T09:30:00Z"],
                rejected: ["2024-01-15T09:30:00Z", "2024-01-15T09:30:00Z"],
                complained: ["2024-01-15T09:30:00Z", "2024-01-15T09:30:00Z"],
                received: ["2024-01-15T09:30:00Z", "2024-01-15T09:30:00Z"],
            },
        };
        server
            .mockEndpoint()
            .get("/v0/inboxes/inbox_id/metrics")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.inboxes.metrics.get("inbox_id", {
            startTimestamp: new Date("2024-01-15T09:30:00.000Z"),
            endTimestamp: new Date("2024-01-15T09:30:00.000Z"),
        });
        expect(response).toEqual({
            message: {
                sent: [new Date("2024-01-15T09:30:00.000Z"), new Date("2024-01-15T09:30:00.000Z")],
                delivered: [new Date("2024-01-15T09:30:00.000Z"), new Date("2024-01-15T09:30:00.000Z")],
                bounced: [new Date("2024-01-15T09:30:00.000Z"), new Date("2024-01-15T09:30:00.000Z")],
                delayed: [new Date("2024-01-15T09:30:00.000Z"), new Date("2024-01-15T09:30:00.000Z")],
                rejected: [new Date("2024-01-15T09:30:00.000Z"), new Date("2024-01-15T09:30:00.000Z")],
                complained: [new Date("2024-01-15T09:30:00.000Z"), new Date("2024-01-15T09:30:00.000Z")],
                received: [new Date("2024-01-15T09:30:00.000Z"), new Date("2024-01-15T09:30:00.000Z")],
            },
        });
    });

    test("get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new AgentMailClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { http: server.baseUrl, websockets: server.baseUrl },
        });

        const rawResponseBody = { name: "name", message: "message" };
        server
            .mockEndpoint()
            .get("/v0/inboxes/inbox_id/metrics")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.inboxes.metrics.get("inbox_id", {
                startTimestamp: new Date("2024-01-15T09:30:00.000Z"),
                endTimestamp: new Date("2024-01-15T09:30:00.000Z"),
            });
        }).rejects.toThrow(AgentMail.NotFoundError);
    });

    test("get (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new AgentMailClient({
            maxRetries: 0,
            apiKey: "test",
            environment: { http: server.baseUrl, websockets: server.baseUrl },
        });

        const rawResponseBody = { name: "name", errors: { key: "value" } };
        server
            .mockEndpoint()
            .get("/v0/inboxes/inbox_id/metrics")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.inboxes.metrics.get("inbox_id", {
                startTimestamp: new Date("2024-01-15T09:30:00.000Z"),
                endTimestamp: new Date("2024-01-15T09:30:00.000Z"),
            });
        }).rejects.toThrow(AgentMail.ValidationError);
    });
});
